{"ast":null,"code":"import { LogLevel, SnackbarMessageLoggingMap } from '@core/interfaces/logger.interface';\nimport { ConsoleTransport } from '@core/services/logger/console-transport';\nimport { LogEntry } from '@core/services/logger/log-entry';\nimport { NotificationService } from '@core/services/notification/notification.service';\nimport { environment, LOG_LEVEL } from 'src/environments/environment';\n/**\n * The application logger. This is not a service and does not need to be injected in the constructor but can\n * be referenced statically.\n *\n * @example\n * Logger.log(LogLevel.debug, 'this is a message', foo);\n * Logger.log(LogLevel.info, 'this is a message');\n * Logger.debug('this is a message', foo);\n * Logger.info('this is a message');\n * Logger.error(err.message, err);\n */\n\nexport class Logger {\n  static error(message, ...optionalParams) {\n    Logger.writeToLog(LogLevel.error, message, optionalParams);\n  }\n\n  static warn(message, ...optionalParams) {\n    Logger.writeToLog(LogLevel.warn, message, optionalParams);\n  }\n\n  static info(message, ...optionalParams) {\n    Logger.writeToLog(LogLevel.info, message, optionalParams);\n  }\n\n  static verbose(message, ...optionalParams) {\n    Logger.writeToLog(LogLevel.verbose, message, optionalParams);\n  }\n\n  static debug(message, ...optionalParams) {\n    Logger.writeToLog(LogLevel.debug, message, optionalParams);\n  }\n\n  static silly(message, ...optionalParams) {\n    Logger.writeToLog(LogLevel.silly, message, optionalParams);\n  }\n\n  static log(level, message, ...optionalParams) {\n    Logger.writeToLog(level, message, optionalParams);\n  }\n  /**\n   * Send the log entry off to the transport. Will display or store the log entry\n   * @param {LogLevel} level\n   * @param {string} message\n   * @param {any[]} optionalParams\n   */\n\n\n  static writeToLog(level, message, ...optionalParams) {\n    if (Logger.shouldLog(level)) {\n      const logEntry = new LogEntry(level, message, ...optionalParams);\n      Logger.transports.forEach(transport => {\n        const loggedEntry = transport.logMessage(logEntry);\n\n        if (loggedEntry.shouldNotifyUser) {\n          NotificationService.showSnackbar({\n            message: loggedEntry.message,\n            messageType: SnackbarMessageLoggingMap[level]\n          });\n        }\n      });\n    }\n  }\n  /**\n   * Determines if a log entry should actually be logged\n   * @param level\n   * @returns {boolean}\n   */\n\n\n  static shouldLog(level) {\n    let returnVal = false;\n\n    if (level <= Logger.level) {\n      returnVal = true;\n    }\n\n    return returnVal;\n  }\n\n}\n/**\n * The application logging level. Set this to the highest logging\n * level you want to be used. If you look at the LogLevel enum, each level\n * is an integer with silly being 5 and error being 0. So setting the\n * LogLevel to info (2) all lower logging levels WILL also be logged (i.e. warn (1) and error (0))\n * but verbose (3), debug (4) and silly (5) will NOT be logged.\n */\n\nLogger.level = LOG_LEVEL;\n/**\n * Array of transports. There should be a transport for every logging type you\n * might need\n */\n\nLogger.transports = environment.production ? [new ConsoleTransport(Logger.level, true)] : [new ConsoleTransport(Logger.level)];","map":null,"metadata":{},"sourceType":"module"}