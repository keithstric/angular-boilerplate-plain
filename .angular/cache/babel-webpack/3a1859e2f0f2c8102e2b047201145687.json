{"ast":null,"code":"import * as i1 from '@ngrx/store';\nimport { createAction, props, isNgrxMockEnvironment, select, ACTIVE_RUNTIME_CHECKS, createFeatureSelector, createSelector } from '@ngrx/store';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, NgModule, Inject } from '@angular/core';\nimport * as i2 from '@angular/router';\nimport { NavigationStart, RoutesRecognized, NavigationCancel, NavigationError, NavigationEnd } from '@angular/router';\nimport { withLatestFrom } from 'rxjs/operators';\n/**\n * An action dispatched when a router navigation request is fired.\n */\n\nconst ROUTER_REQUEST = '@ngrx/router-store/request';\nconst routerRequestAction = createAction(ROUTER_REQUEST, props());\n/**\n * An action dispatched when the router navigates.\n */\n\nconst ROUTER_NAVIGATION = '@ngrx/router-store/navigation';\nconst routerNavigationAction = createAction(ROUTER_NAVIGATION, props());\n/**\n * An action dispatched when the router cancels navigation.\n */\n\nconst ROUTER_CANCEL = '@ngrx/router-store/cancel';\nconst routerCancelAction = createAction(ROUTER_CANCEL, props());\n/**\n * An action dispatched when the router errors.\n */\n\nconst ROUTER_ERROR = '@ngrx/router-store/error';\nconst routerErrorAction = createAction(ROUTER_ERROR, props());\n/**\n * An action dispatched after navigation has ended and new route is active.\n */\n\nconst ROUTER_NAVIGATED = '@ngrx/router-store/navigated';\nconst routerNavigatedAction = createAction(ROUTER_NAVIGATED, props());\n\nfunction routerReducer(state, action) {\n  // Allow compilation with strictFunctionTypes - ref: #1344\n  const routerAction = action;\n\n  switch (routerAction.type) {\n    case ROUTER_NAVIGATION:\n    case ROUTER_ERROR:\n    case ROUTER_CANCEL:\n      return {\n        state: routerAction.payload.routerState,\n        navigationId: routerAction.payload.event.id\n      };\n\n    default:\n      return state;\n  }\n}\n\nclass RouterStateSerializer {}\n\nclass DefaultRouterStateSerializer {\n  serialize(routerState) {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url\n    };\n  }\n\n  serializeRoute(route) {\n    const children = route.children.map(c => this.serializeRoute(c));\n    return {\n      params: route.params,\n      paramMap: route.paramMap,\n      data: route.data,\n      url: route.url,\n      outlet: route.outlet,\n      routeConfig: route.routeConfig ? {\n        component: route.routeConfig.component,\n        path: route.routeConfig.path,\n        pathMatch: route.routeConfig.pathMatch,\n        redirectTo: route.routeConfig.redirectTo,\n        outlet: route.routeConfig.outlet\n      } : null,\n      queryParams: route.queryParams,\n      queryParamMap: route.queryParamMap,\n      fragment: route.fragment,\n      component: route.routeConfig ? route.routeConfig.component : undefined,\n      root: undefined,\n      parent: undefined,\n      firstChild: children[0],\n      pathFromRoot: undefined,\n      children\n    };\n  }\n\n}\n\nclass MinimalRouterStateSerializer {\n  serialize(routerState) {\n    return {\n      root: this.serializeRoute(routerState.root),\n      url: routerState.url\n    };\n  }\n\n  serializeRoute(route) {\n    const children = route.children.map(c => this.serializeRoute(c));\n    return {\n      params: route.params,\n      data: route.data,\n      url: route.url,\n      outlet: route.outlet,\n      routeConfig: route.routeConfig ? {\n        path: route.routeConfig.path,\n        pathMatch: route.routeConfig.pathMatch,\n        redirectTo: route.routeConfig.redirectTo,\n        outlet: route.routeConfig.outlet\n      } : null,\n      queryParams: route.queryParams,\n      fragment: route.fragment,\n      firstChild: children[0],\n      children\n    };\n  }\n\n}\n\nvar NavigationActionTiming = /*#__PURE__*/(() => {\n  (function (NavigationActionTiming) {\n    NavigationActionTiming[NavigationActionTiming[\"PreActivation\"] = 1] = \"PreActivation\";\n    NavigationActionTiming[NavigationActionTiming[\"PostActivation\"] = 2] = \"PostActivation\";\n  })(NavigationActionTiming || (NavigationActionTiming = {}));\n\n  return NavigationActionTiming;\n})();\n\nconst _ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Internal Configuration');\n\nconst ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Configuration');\nconst DEFAULT_ROUTER_FEATURENAME = 'router';\n\nfunction _createRouterConfig(config) {\n  return {\n    stateKey: DEFAULT_ROUTER_FEATURENAME,\n    serializer: MinimalRouterStateSerializer,\n    navigationActionTiming: NavigationActionTiming.PreActivation,\n    ...config\n  };\n}\n\nvar RouterTrigger = /*#__PURE__*/(() => {\n  (function (RouterTrigger) {\n    RouterTrigger[RouterTrigger[\"NONE\"] = 1] = \"NONE\";\n    RouterTrigger[RouterTrigger[\"ROUTER\"] = 2] = \"ROUTER\";\n    RouterTrigger[RouterTrigger[\"STORE\"] = 3] = \"STORE\";\n  })(RouterTrigger || (RouterTrigger = {}));\n\n  return RouterTrigger;\n})();\n\n/**\n * Connects RouterModule with StoreModule.\n *\n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n *\n * ```\n * export type RouterNavigationPayload = {\n *   routerState: SerializedRouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n *\n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n *\n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n *\n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n *\n * Usage:\n *\n * ```typescript\n * @NgModule({\n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.forRoot(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule.forRoot()\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\nlet StoreRouterConnectingModule = /*#__PURE__*/(() => {\n  class StoreRouterConnectingModule {\n    constructor(store, router, serializer, errorHandler, config, activeRuntimeChecks) {\n      this.store = store;\n      this.router = router;\n      this.serializer = serializer;\n      this.errorHandler = errorHandler;\n      this.config = config;\n      this.activeRuntimeChecks = activeRuntimeChecks;\n      this.lastEvent = null;\n      this.routerState = null;\n      this.trigger = RouterTrigger.NONE;\n      this.stateKey = this.config.stateKey;\n\n      if (!isNgrxMockEnvironment() && isDevMode() && (activeRuntimeChecks?.strictActionSerializability || activeRuntimeChecks?.strictStateSerializability) && this.serializer instanceof DefaultRouterStateSerializer) {\n        console.warn('@ngrx/router-store: The serializability runtime checks cannot be enabled ' + 'with the DefaultRouterStateSerializer. The default serializer ' + 'has an unserializable router state and actions that are not serializable. ' + 'To use the serializability runtime checks either use ' + 'the MinimalRouterStateSerializer or implement a custom router state serializer. ' + 'This also applies to Ivy with immutability runtime checks.');\n      }\n\n      this.setUpStoreStateListener();\n      this.setUpRouterEventsListener();\n    }\n\n    static forRoot(config = {}) {\n      return {\n        ngModule: StoreRouterConnectingModule,\n        providers: [{\n          provide: _ROUTER_CONFIG,\n          useValue: config\n        }, {\n          provide: ROUTER_CONFIG,\n          useFactory: _createRouterConfig,\n          deps: [_ROUTER_CONFIG]\n        }, {\n          provide: RouterStateSerializer,\n          useClass: config.serializer ? config.serializer : config.routerState === 0\n          /* Full */\n          ? DefaultRouterStateSerializer : MinimalRouterStateSerializer\n        }]\n      };\n    }\n\n    setUpStoreStateListener() {\n      this.store.pipe(select(this.stateKey), withLatestFrom(this.store)).subscribe(([routerStoreState, storeState]) => {\n        this.navigateIfNeeded(routerStoreState, storeState);\n      });\n    }\n\n    navigateIfNeeded(routerStoreState, storeState) {\n      if (!routerStoreState || !routerStoreState.state) {\n        return;\n      }\n\n      if (this.trigger === RouterTrigger.ROUTER) {\n        return;\n      }\n\n      if (this.lastEvent instanceof NavigationStart) {\n        return;\n      }\n\n      const url = routerStoreState.state.url;\n\n      if (!isSameUrl(this.router.url, url)) {\n        this.storeState = storeState;\n        this.trigger = RouterTrigger.STORE;\n        this.router.navigateByUrl(url).catch(error => {\n          this.errorHandler.handleError(error);\n        });\n      }\n    }\n\n    setUpRouterEventsListener() {\n      const dispatchNavLate = this.config.navigationActionTiming === NavigationActionTiming.PostActivation;\n      let routesRecognized;\n      this.router.events.pipe(withLatestFrom(this.store)).subscribe(([event, storeState]) => {\n        this.lastEvent = event;\n\n        if (event instanceof NavigationStart) {\n          this.routerState = this.serializer.serialize(this.router.routerState.snapshot);\n\n          if (this.trigger !== RouterTrigger.STORE) {\n            this.storeState = storeState;\n            this.dispatchRouterRequest(event);\n          }\n        } else if (event instanceof RoutesRecognized) {\n          routesRecognized = event;\n\n          if (!dispatchNavLate && this.trigger !== RouterTrigger.STORE) {\n            this.dispatchRouterNavigation(event);\n          }\n        } else if (event instanceof NavigationCancel) {\n          this.dispatchRouterCancel(event);\n          this.reset();\n        } else if (event instanceof NavigationError) {\n          this.dispatchRouterError(event);\n          this.reset();\n        } else if (event instanceof NavigationEnd) {\n          if (this.trigger !== RouterTrigger.STORE) {\n            if (dispatchNavLate) {\n              this.dispatchRouterNavigation(routesRecognized);\n            }\n\n            this.dispatchRouterNavigated(event);\n          }\n\n          this.reset();\n        }\n      });\n    }\n\n    dispatchRouterRequest(event) {\n      this.dispatchRouterAction(ROUTER_REQUEST, {\n        event\n      });\n    }\n\n    dispatchRouterNavigation(lastRoutesRecognized) {\n      const nextRouterState = this.serializer.serialize(lastRoutesRecognized.state);\n      this.dispatchRouterAction(ROUTER_NAVIGATION, {\n        routerState: nextRouterState,\n        event: new RoutesRecognized(lastRoutesRecognized.id, lastRoutesRecognized.url, lastRoutesRecognized.urlAfterRedirects, nextRouterState)\n      });\n    }\n\n    dispatchRouterCancel(event) {\n      this.dispatchRouterAction(ROUTER_CANCEL, {\n        storeState: this.storeState,\n        event\n      });\n    }\n\n    dispatchRouterError(event) {\n      this.dispatchRouterAction(ROUTER_ERROR, {\n        storeState: this.storeState,\n        event: new NavigationError(event.id, event.url, `${event}`)\n      });\n    }\n\n    dispatchRouterNavigated(event) {\n      const routerState = this.serializer.serialize(this.router.routerState.snapshot);\n      this.dispatchRouterAction(ROUTER_NAVIGATED, {\n        event,\n        routerState\n      });\n    }\n\n    dispatchRouterAction(type, payload) {\n      this.trigger = RouterTrigger.ROUTER;\n\n      try {\n        this.store.dispatch({\n          type,\n          payload: {\n            routerState: this.routerState,\n            ...payload,\n            event: this.config.routerState === 0\n            /* Full */\n            ? payload.event : {\n              id: payload.event.id,\n              url: payload.event.url,\n              // safe, as it will just be `undefined` for non-NavigationEnd router events\n              urlAfterRedirects: payload.event.urlAfterRedirects\n            }\n          }\n        });\n      } finally {\n        this.trigger = RouterTrigger.NONE;\n      }\n    }\n\n    reset() {\n      this.trigger = RouterTrigger.NONE;\n      this.storeState = null;\n      this.routerState = null;\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  StoreRouterConnectingModule.ɵfac = function StoreRouterConnectingModule_Factory(t) {\n    return new (t || StoreRouterConnectingModule)(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.Router), i0.ɵɵinject(RouterStateSerializer), i0.ɵɵinject(i0.ErrorHandler), i0.ɵɵinject(ROUTER_CONFIG), i0.ɵɵinject(ACTIVE_RUNTIME_CHECKS));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  StoreRouterConnectingModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StoreRouterConnectingModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  StoreRouterConnectingModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return StoreRouterConnectingModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Check if the URLs are matching. Accounts for the possibility of trailing \"/\" in url.\n */\n\n\nfunction isSameUrl(first, second) {\n  return stripTrailingSlash(first) === stripTrailingSlash(second);\n}\n\nfunction stripTrailingSlash(text) {\n  if (text?.length > 0 && text[text.length - 1] === '/') {\n    return text.substring(0, text.length - 1);\n  }\n\n  return text;\n}\n\nfunction createRouterSelector() {\n  return createFeatureSelector(DEFAULT_ROUTER_FEATURENAME);\n}\n\nfunction getSelectors(selectState = createRouterSelector()) {\n  const selectRouterState = createSelector(selectState, router => router && router.state);\n  const selectRootRoute = createSelector(selectRouterState, routerState => routerState && routerState.root);\n  const selectCurrentRoute = createSelector(selectRootRoute, rootRoute => {\n    if (!rootRoute) {\n      return undefined;\n    }\n\n    let route = rootRoute;\n\n    while (route.firstChild) {\n      route = route.firstChild;\n    }\n\n    return route;\n  });\n  const selectFragment = createSelector(selectRootRoute, route => route && route.fragment);\n  const selectQueryParams = createSelector(selectRootRoute, route => route && route.queryParams);\n\n  const selectQueryParam = param => createSelector(selectQueryParams, params => params && params[param]);\n\n  const selectRouteParams = createSelector(selectCurrentRoute, route => route && route.params);\n\n  const selectRouteParam = param => createSelector(selectRouteParams, params => params && params[param]);\n\n  const selectRouteData = createSelector(selectCurrentRoute, route => route && route.data);\n  const selectUrl = createSelector(selectRouterState, routerState => routerState && routerState.url);\n  return {\n    selectCurrentRoute,\n    selectFragment,\n    selectQueryParams,\n    selectQueryParam,\n    selectRouteParams,\n    selectRouteParam,\n    selectRouteData,\n    selectUrl\n  };\n}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DEFAULT_ROUTER_FEATURENAME, DefaultRouterStateSerializer, MinimalRouterStateSerializer, NavigationActionTiming, ROUTER_CANCEL, ROUTER_CONFIG, ROUTER_ERROR, ROUTER_NAVIGATED, ROUTER_NAVIGATION, ROUTER_REQUEST, RouterStateSerializer, StoreRouterConnectingModule, createRouterSelector, getSelectors, routerCancelAction, routerErrorAction, routerNavigatedAction, routerNavigationAction, routerReducer, routerRequestAction };","map":null,"metadata":{},"sourceType":"module"}