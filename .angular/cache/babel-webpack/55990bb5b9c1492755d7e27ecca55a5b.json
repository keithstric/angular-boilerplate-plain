{"ast":null,"code":"import 'reflect-metadata';\nimport { internalMetadataKey, modelKeyMetadataKey, rawKeyMetadataKey, serialMetadataKey } from './serializers/serial'; // tslint:disable-next-line:no-shadowed-variable\n\nexport function createModel(Mapping) {\n  Mapping.serialize = Mapping.serialize.bind(Mapping);\n  Mapping.deserialize = Mapping.deserialize.bind(Mapping);\n  return Mapping;\n}\nexport class Mapping {\n  static serialize(model, options) {\n    if (model === undefined) {\n      return undefined;\n    }\n\n    if (model === null) {\n      return null;\n    }\n\n    return model.toJSON(undefined, options);\n  }\n\n  static deserialize(raw) {\n    if (raw === undefined) {\n      return undefined;\n    }\n\n    if (raw === null) {\n      return null;\n    }\n\n    return new this().applyRaw(raw);\n  }\n\n  constructor(model) {\n    this.apply(model);\n  }\n\n  apply(model) {\n    Object.assign(this, model);\n    return this;\n  }\n  /**\n   * Update the model's properties from the raw JSON object's properties\n   * @param raw {Raw}\n   * @returns {Mapping}\n   */\n\n\n  applyRaw(raw) {\n    if (!raw) {\n      return this;\n    }\n\n    const model = {};\n    const keys = Object.keys(raw);\n\n    for (const key of keys) {\n      const value = raw[key];\n      const modelKey = Reflect.getMetadata(modelKeyMetadataKey, this, key) || key;\n      const serial = Reflect.getMetadata(serialMetadataKey, this, modelKey);\n\n      if (serial) {\n        if (Array.isArray(serial)) {\n          if (Array.isArray(value)) {\n            model[modelKey] = value.map(v => serial[0].deserialize(v));\n          }\n        } else {\n          model[modelKey] = serial.deserialize(value);\n        }\n      } else {\n        model[modelKey] = value;\n      }\n    }\n\n    return this.apply(model);\n  } // even though we are not using `parentKey`, it's there for a placeholder as the first param of `toJSON` is being used by Node.js\n\n\n  toJSON(parentKey, options) {\n    const raw = {};\n    const keys = Object.keys(this);\n    const internalKeys = Reflect.getMetadata(internalMetadataKey, this) || [];\n\n    for (const key of keys) {\n      if (!(options && options.internals) && internalKeys.includes(key)) {\n        continue;\n      }\n\n      const value = this[key];\n      const rawKey = Reflect.getMetadata(rawKeyMetadataKey, this, key) || key;\n      const serial = Reflect.getMetadata(serialMetadataKey, this, key);\n\n      if (serial) {\n        if (Array.isArray(serial)) {\n          if (Array.isArray(value)) {\n            raw[rawKey] = value.map(v => serial[0].serialize(v, options));\n          }\n        } else {\n          raw[rawKey] = serial.serialize(value, options);\n        }\n      } else {\n        raw[rawKey] = value;\n      }\n    }\n\n    return raw;\n  } // serialize + stringify + parse + deserialize = deep clone\n\n\n  clone(options = {\n    internals: true\n  }) {\n    const raw = JSON.parse(JSON.stringify(this.toJSON(undefined, options))); // tslint:disable-next-line:no-shadowed-variable\n\n    const Model = this.constructor;\n    return new Model().applyRaw(raw);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}