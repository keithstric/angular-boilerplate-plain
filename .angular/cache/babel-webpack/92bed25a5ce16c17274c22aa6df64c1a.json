{"ast":null,"code":"import { ApiMethod, ApiRouteToClass } from '@core/interfaces/api.interface';\nimport { catchError, map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@core/services/error-handler/error-handler.service\";\nimport * as i3 from \"@angular/router\";\n/**\n * This service is for handling all http requests and responses. If an error occurs, handle the error.\n * If the request route is defined in {@link ApiRouteToClass} will automatically deserialize the Raw object\n * into it's respective class.\n */\n\nexport let HttpService = /*#__PURE__*/(() => {\n  class HttpService {\n    constructor(_http, _error, _router) {\n      this._http = _http;\n      this._error = _error;\n      this._router = _router;\n    }\n    /**\n     * Make an http request\n     * @param apiUrl {ApiEndpoints | string}\n     * @param method {ApiMethod}\n     * @param body {any}\n     * @param config\n     * @returns {Observable<any>}\n     */\n\n\n    doRequest(apiUrl, method, body, config) {\n      let response;\n      let reqObservable;\n\n      if (method === ApiMethod.GET || method === ApiMethod.DELETE) {\n        if (!config && body) {\n          config = {\n            observe: body\n          };\n        } else if (config && body) {\n          config.observe = body;\n        }\n      }\n\n      switch (method) {\n        case ApiMethod.GET:\n          reqObservable = this._http.get(apiUrl, config);\n          break;\n\n        case ApiMethod.DELETE:\n          reqObservable = this._http.delete(apiUrl, config);\n          break;\n\n        case ApiMethod.PATCH:\n          reqObservable = this._http.patch(apiUrl, body, config);\n          break;\n\n        case ApiMethod.POST:\n          reqObservable = this._http.post(apiUrl, body, config);\n          break;\n\n        case ApiMethod.PUT:\n          reqObservable = this._http.put(apiUrl, body, config);\n          break;\n      }\n\n      response = reqObservable.pipe(map(resp => {\n        const clazz = this.getRouteClass(apiUrl);\n\n        if (clazz) {\n          if (Array.isArray(resp)) {\n            return resp.map(item => clazz.deserialize(item));\n          } else {\n            return clazz.deserialize(resp);\n          }\n        }\n\n        return resp;\n      }), catchError(err => {\n        throw err;\n      }));\n      return response;\n    }\n    /**\n     * Assumes an apiUrl like \"/api/something/...\" that matches\n     * @param {string} apiUrl\n     * @returns {Class | undefined}\n     * {@link ApiRouteToClass}\n     */\n\n\n    getRouteClass(apiUrl) {\n      let clazz;\n\n      if (apiUrl) {\n        const pathKey = apiUrl.split('/').filter(Boolean) // remove empty string/null/undefined items\n        .slice(0, 2) // remove everything past the 2nd path part (i.e. '/api/auth/<remove>/<everything>/<else>\n        .join('/'); // Put it all back together\n\n        clazz = ApiRouteToClass[`/${pathKey}`] || undefined;\n      }\n\n      return clazz;\n    }\n\n  }\n\n  HttpService.ɵfac = function HttpService_Factory(t) {\n    return new (t || HttpService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.AppErrorHandler), i0.ɵɵinject(i3.Router));\n  };\n\n  HttpService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: HttpService,\n    factory: HttpService.ɵfac,\n    providedIn: 'root'\n  });\n  return HttpService;\n})();","map":null,"metadata":{},"sourceType":"module"}