{"ast":null,"code":"import { LogLevel, LogLevelNameMap } from '@core/interfaces/logger.interface';\nimport { AbstractTransport } from '@core/services/logger/abstract-transport';\nimport { LogEntry } from '@core/services/logger/log-entry';\nimport { ServiceLocator } from '@core/services/service-locator';\nimport { Store } from '@ngrx/store';\n/**\n * This is a console logger transport. Will display all received log entries in the console\n */\n\nexport class ConsoleTransport extends AbstractTransport {\n  constructor(level, takeOverConsoleLog = false) {\n    super(level);\n    this.logWithDate = false;\n    this.shouldPersist = false;\n    this.shouldNotifyUser = false;\n    this.logLevelColors = ['color: #de1414;', 'color: #fff3cd;', 'color: #d1ecf1;', 'color: #856404;', 'color: #d4edda;', 'color: #f8d7da;'];\n\n    this._listenToStore();\n\n    if (takeOverConsoleLog) {\n      this.takeOverConsoleLog();\n    }\n  }\n\n  _listenToStore() {\n    ServiceLocator.observableInjector.subscribe(injector => {\n      if (injector && !this.storeListener) {\n        const store = injector.get(Store);\n        this.storeListener = store.select(appState => appState).subscribe(appState => {\n          this.appState = Object.assign({}, appState);\n        });\n      }\n    });\n  }\n  /**\n   * Take over console.log and redirect it to use this transport instead. This is mainly to change\n   * the level to DEBUG in order to prevent console.log messages from being displayed\n   * in the production environment\n   * @private\n   */\n\n\n  takeOverConsoleLog() {\n    this.consoleLog = console.log;\n\n    console.log = (...args) => {\n      const msg = args[0];\n      const vars = args.splice(1);\n      let logEntry = new LogEntry(LogLevel.debug, msg);\n\n      if (vars === null || vars === void 0 ? void 0 : vars.length) {\n        logEntry = new LogEntry(LogLevel.debug, msg, vars);\n      }\n\n      this.logMessage(logEntry);\n    };\n  }\n  /**\n   * Get all the different log parts for styling purposes\n   * @param {LogEntry} logEntry\n   * @private\n   */\n\n\n  _getLogParts(logEntry) {\n    const levelColor = this.logLevelColors[logEntry.level];\n    return [{\n      partName: 'level',\n      styles: `${levelColor} font-weight: bold; font-size: 1.1em`,\n      value: `%c${LogLevelNameMap[logEntry.level]} - `\n    }, {\n      partName: 'date',\n      styles: 'color: default;',\n      value: `%c${logEntry.entryDate} - `\n    }, {\n      partName: 'message',\n      styles: levelColor,\n      value: `%c${logEntry.message}`\n    }];\n  }\n  /**\n   * Add formatting to the message to be displayed\n   * @param logEntry\n   * @returns {FormattedMessage}\n   */\n\n\n  formatMessage(logEntry) {\n    let message = '';\n\n    const logParts = this._getLogParts(logEntry);\n\n    const replacementVars = [];\n    logParts.forEach(logPart => {\n      if (logPart.partName !== 'date' || logPart.partName === 'date' && logEntry.logWithDate) {\n        message += logPart.value;\n        replacementVars.push(logPart.styles);\n      }\n    });\n    return {\n      message,\n      replacementVars\n    };\n  }\n  /**\n   * Show the log message\n   * @param logEntry\n   * @returns {LogEntry}\n   */\n\n\n  log(logEntry) {\n    const formatMsg = this.formatMessage(logEntry);\n    let message = formatMsg.message;\n    let vars = formatMsg.replacementVars;\n\n    if (logEntry.params && logEntry.params.length) {\n      message += ' %o';\n      vars = [...formatMsg.replacementVars, ...logEntry.params];\n    } // Send message to console\n\n\n    if (logEntry.level !== LogLevel.error) {\n      if (logEntry.level === LogLevel.debug) {\n        console.debug(message, ...vars);\n      } else {\n        if (this.consoleLog) {\n          this.consoleLog(message, ...vars);\n        } else {\n          console.log(message, ...vars);\n        }\n      }\n    } else {\n      vars = [...vars, {\n        appState: this.appState\n      }];\n      console.error(message, ...vars);\n    }\n\n    return logEntry;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}