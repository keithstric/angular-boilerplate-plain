{"ast":null,"code":"import { DomInjectorService } from '@core/services/dom-injector/dom-injector.service';\nimport { SnackBarComponent } from '@shared/components/snack-bar/snack-bar.component';\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n/**\n * this class is for controlling the display and dismissal of toast/snackbar notifications. If multiple\n * snackbars are received, it will que (FIFO) the requests and show each one after the previous one is dismissed.\n *\n * @example\n *\n * ```js\n * @Injectable()\n * export class NotificationService {\n *\n *   constructor(private _snackbarRef: SnackBarRef) {}\n *\n *   showSnackbar() {\n *     const config = {\n *     message: 'Here is a snackbar message',\n *     messageType: SnackbarMessageTypes.SUCCESS,\n *     duration: 5000,\n *     action: {\n *       label: 'OK',\n *       action: () => {\n *         console.log('action clicked')}\n *       }\n *     }\n *     this._snackbarRef.show(config);\n *   }\n * }\n * ```\n */\n\nexport let SnackBarRef = /*#__PURE__*/(() => {\n  class SnackBarRef {\n    constructor(_injector) {\n      this._injector = _injector;\n      /**\n       * The queue of snackbars to display. This queue is FIFO\n       * @private\n       */\n\n      this.snackbarsQue = new BehaviorSubject([]);\n\n      this._listenToSnackBars();\n    }\n    /**\n     * Setup a listener for the snackbarsQue. Will display each snackbar in the que once\n     * the currently displayed snackbar is dismissed and the que changes\n     */\n\n\n    _listenToSnackBars() {\n      this.snackbarsQue.subscribe(snackBars => {\n        if (snackBars && snackBars.length) {\n          if (!this._currentSnackbar) {\n            this._displaySnackbar(snackBars[0]);\n          }\n        }\n      });\n    }\n    /**\n     * Create the SnackbarDisplay and add it to the que\n     * @param {SnackbarConfig} config\n     * @returns {ComponentRef}\n     */\n\n\n    show(config) {\n      if (!this._domInjector) {\n        this._domInjector = this._injector.get(DomInjectorService);\n      }\n\n      const componentRef = this._domInjector.createComponent(SnackBarComponent, config);\n\n      const snackbars = this.snackbarsQue.value;\n      snackbars.push({\n        componentRef,\n        config\n      });\n      this.snackbarsQue.next(snackbars);\n      return componentRef;\n    }\n    /**\n     * Display the snackbar, setup the dismiss timer, set _currentSnackbar\n     * @param currentSnackbar\n     * @private\n     */\n\n\n    _displaySnackbar(currentSnackbar) {\n      if (currentSnackbar) {\n        const {\n          componentRef,\n          config\n        } = currentSnackbar; // remove snackbar after set time\n\n        currentSnackbar.timeout = setTimeout(() => {\n          this.dismiss();\n        }, config.duration || 5000);\n        this._currentSnackbar = currentSnackbar;\n\n        this._setSnackbarDismissEventHandler(componentRef.instance);\n\n        this._domInjector.attachComponent(componentRef, document.body);\n      }\n    }\n    /**\n     * Dismiss the snackbar. Clear the timer, add the exit animation, then once\n     * the animation is done, clear the _currentSnackbar and get rid of the top\n     * element in the que. Do not run the action unless the action button is\n     * clicked on\n     * @returns {Promise}\n     */\n\n\n    dismiss() {\n      clearTimeout(this._currentSnackbar.timeout);\n\n      this._addExitAnimationClass(); // wait for animation to finish, animation is 500ms\n\n\n      setTimeout(() => {\n        const {\n          componentRef\n        } = this._currentSnackbar;\n\n        this._domInjector.removeComponent(componentRef);\n\n        this._currentSnackbar = undefined;\n        const currQue = this.snackbarsQue.value;\n        currQue.shift();\n        this.snackbarsQue.next(currQue);\n      }, 510);\n    }\n    /**\n     * Setup the event handler to catch the dismiss event from the snackbar component.\n     * Runs the action and then dismisses the snackbar\n     * @param snackBar\n     * @private\n     */\n\n\n    _setSnackbarDismissEventHandler(snackBar) {\n      snackBar.dismissSnackbar.subscribe(() => {\n        this._runAction().then(() => {\n          this.dismiss();\n        });\n      });\n    }\n    /**\n     * Get the app-snackbar DOM element\n     * @private\n     */\n\n\n    _getDomElement() {\n      const {\n        componentRef\n      } = this._currentSnackbar;\n      return componentRef.hostView.rootNodes[0];\n    }\n    /**\n     * Adds the dismiss-animation style class to the snackbar container\n     * @private\n     */\n\n\n    _addExitAnimationClass() {\n      const domElement = this._getDomElement();\n\n      const domContainer = domElement.querySelector('.snackbar-container');\n      domContainer.classList.add('dismiss-animation');\n    }\n    /**\n     * Run any action handler that is defined in the config\n     * @returns {Promise}\n     * @private\n     */\n\n\n    _runAction() {\n      const {\n        config\n      } = this._currentSnackbar;\n      return new Promise((resolve, reject) => {\n        if (config.action && config.action.actionHandler) {\n          config.action.actionHandler();\n        }\n\n        resolve(true);\n      });\n    }\n\n  }\n\n  SnackBarRef.ɵfac = function SnackBarRef_Factory(t) {\n    return new (t || SnackBarRef)(i0.ɵɵinject(i0.Injector));\n  };\n\n  SnackBarRef.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: SnackBarRef,\n    factory: SnackBarRef.ɵfac\n  });\n  return SnackBarRef;\n})();","map":null,"metadata":{},"sourceType":"module"}