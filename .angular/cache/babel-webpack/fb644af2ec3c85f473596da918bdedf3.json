{"ast":null,"code":"import { ErrorHandler } from '@angular/core';\nimport { Logger } from '@core/services/logger/logger';\nimport { NotificationService } from '@core/services/notification/notification.service';\nimport { SnackbarMessageTypes } from '@shared/components/snack-bar/snack-bar.interface';\nimport { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n/**\n * This service is for surfacing errors in the UI. By default, we'll notify the user with a snackbar (toast) message.\n * You should only need to include this service if you need to surface errors in the ui or need to notify the user\n * of errors.\n */\n\nexport let AppErrorHandler = /*#__PURE__*/(() => {\n  class AppErrorHandler extends ErrorHandler {\n    constructor() {\n      super();\n      this.errorEvent = new Subject();\n    }\n    /**\n     * Create a snackbar notification\n     * @param {number} notificationCode - An error code or Http Status\n     * @param {string} notification - The notification message\n     */\n\n\n    notifyUserSnackbar(notificationCode, notification) {\n      const snackbarConfig = {\n        message: `${notificationCode}: ${notification}`,\n        duration: 5000,\n        messageType: SnackbarMessageTypes.DANGER\n      };\n      NotificationService.showSnackbar(snackbarConfig);\n    }\n    /**\n     * This function is a global javascript error handler. It will catch all javascript errors\n     * produced within the application. The docs at https://angular.io/api/core/ErrorHandler say\n     * that err has a type of any. I'm assuming the \"any\" type is so you can pass it a custom error\n     * or error event. console logging the err argument just outputs the stack trace.\n     *\n     * If an error occurs within a try/catch block, this will not be fired unless you\n     * throw the error within the catch block.\n     *\n     * I understand I've got repeated code below, but this is merely a placeholder so that\n     * custom logic can be introduced based on the error type (err.name). You probably don't\n     * want to break it down to that level but instead send to a DB, throw a dialog\n     * for debugging, etc.\n     *\n     * Definition is in @see{src/app/core/core.module.ts}\n     *\n     * @param err {Error}\n     */\n\n\n    handleError(err) {\n      if (err instanceof EvalError) {\n        // console.log('Error Type=EvalError');\n        Logger.error(err.message, err);\n      } else if (err instanceof RangeError) {\n        // console.log('Error Type=RangeError');\n        Logger.error(err.message, err);\n      } else if (err instanceof ReferenceError) {\n        // console.log('Error Type=ReferenceError');\n        Logger.error(err.message, err);\n      } else if (err instanceof SyntaxError) {\n        // console.log('Error Type=SyntaxError');\n        Logger.error(err.message, err);\n      } else if (err instanceof TypeError) {\n        // console.log('Error Type=TypeError');\n        Logger.error(err.message, err);\n      } else if (err instanceof URIError) {\n        // console.log('Error Type=URIError');\n        Logger.error(err.message, err);\n      } else if (err instanceof ErrorEvent) {\n        // console.log('Error Type=ErrorEvent');\n        Logger.error(err.error.message, err);\n      } else {\n        // console.log('Error Type=Unknown');\n        Logger.error(err.message, err);\n      }\n\n      this.errorEvent.next(err);\n    }\n\n  }\n\n  AppErrorHandler.ɵfac = function AppErrorHandler_Factory(t) {\n    return new (t || AppErrorHandler)();\n  };\n\n  AppErrorHandler.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AppErrorHandler,\n    factory: AppErrorHandler.ɵfac,\n    providedIn: 'root'\n  });\n  return AppErrorHandler;\n})();","map":null,"metadata":{},"sourceType":"module"}